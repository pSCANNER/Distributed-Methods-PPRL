package rosita.linkage.filtering;
import java.util.Map;

import net.sourceforge.jgeocoder.AddressComponent;
import net.sourceforge.jgeocoder.JGeocodeAddress;
import net.sourceforge.jgeocoder.us.AddressParser;

import com.globalmentor.text.ArgumentSyntaxException;
import com.google.i18n.phonenumbers.NumberParseException;
import com.google.i18n.phonenumbers.PhoneNumberUtil;
import com.google.i18n.phonenumbers.Phonenumber.PhoneNumber;


/**
 * This class is intended to be a collection of functions that will clean
 * up values for different attributes into some normalized form.
 * 
 * For example, parseSSN takes in an SSN and trashes bogus SSNs and only 
 * allows valid SSNs to be returned to the caller.
 * 
 * This class has been marked as incomplete.
 * 
 * @author Brandon Abbott
 * 
 */
public class Cleaner {

	// This is a place to dump errors generated by this class's members
	private static StringBuilder errLog = new StringBuilder("");

	/**
	 * Simple getter for the error log.  There should be no need to set
	 * the error log from outside this class.
	 * @return - The list of errors created from the cleaner class as a String.
	 */
	public static String getErrLog()
	{
		return errLog.toString();
	}


	/**
	 * This main() is only to be used for testing purposes.  It basically just
	 * checks the validity of some of the functions of the Cleaner class.
	 * 
	 * Feel free to modify the contents of this function without 
	 * worry of breaking anything/
	 * @param args - Command line arguments.
	 */
	public static void main(String args[] )
	{

		String ss = "000000000";
		System.out.println(parseSSN(ss));

		System.exit(0);

		String s = "Colorado";
		Map<AddressComponent, String> m =
			AddressParser.parseAddress(s, true);
		JGeocodeAddress jga = new JGeocodeAddress();
		jga.setParsedAddr(m);
		System.out.println(jga);
		if(m != null)
			for(AddressComponent ac : m.keySet())
				System.out.print(ac.toString() + "  |  " + m.get(ac) + "\n");

	}

	/**
	 * Given some input String containing one's gender, 
	 * return a normalized version of the gender.
	 * @param inSex - Some representation of gender, M/F 0/1, MALE/FEMALE
	 * @return either "F" or "M"
	 */
	public static String parseSex(String inSex){
		if(inSex.length() < 1)
			return "";
		if(inSex.toUpperCase().contains("F") || inSex.contains("0"))
			return "F";
		if(inSex.toUpperCase().contains("MALE") || inSex.contains("1") || inSex.equalsIgnoreCase("M"))
			return "M";

		// TODO: What should be done with meaningless gender information? 
		return "";

	}

	/**
	 * Given some input String containing one's SSN,
	 * return a normalized version of the SSN.
	 * Discards SSNs having non-numeric characters, sets of continuous 0's, etc...
	 * @param inSSN - The SSN to normalize
	 * @return - The SSN in a 9digit form.
	 */
	public static String parseSSN(String inSSN)
	{

		// Avoid strings on incorrect lengths
		if ( ! ( inSSN.length() == 11 || inSSN.length() == 9) )
			return "";

		char [] s = inSSN.toCharArray();

		// Block 000-XX-XXX && 000XXXXXX
		if (s[0] == '0' && s[1] == '0' && s[2] == '0')
			return "";

		if ( s.length == 11 ) {
			// Block XXX-00-XXX
			//if (s[4] == '0' && s[5] == '0')
			//	return "";
			// Block XXX-XX-0000
			//if (s[7] == '0' && s[8] == '0' && s[9] == '0' && s[10] == '0')
			//	return "";
		}


		if (s.length == 9) {
			// Block XXX00XXXX
			//if ( s[3] == '0' && s[4] == '0')
			//	return "";
			// Block XXXXX0000
			//if (s[5] == '0' && s[6] == '0' && s[7] == '0' && s[8] == '0')
			//	return "";
		}

		// Don't accept non-numeric strings
		for (int i = 0; i < s.length; i++)
			if ( ! Character.isDigit(s[i]) && s[i] != '-')
				return "";

		// Finally, try to use the com.globalmentor.country.us.SSN; package to normalize
		try
		{
			//SSN ssn = new SSN(inSSN);
			//return ssn.getPlainString();
			return inSSN.replace("-", "");
		} catch (ArgumentSyntaxException e) {
			System.err.println("Could not parse SSN: " + inSSN);
			System.err.println("Caught Exception.  Program Continuing.");
		}

		return "";

	}


	/**
	 * Normalize a phone number and return in ########## format.
	 * Uses the imports
	 * com.google.i18n.phonenumbers.PhoneNumberUtil;
	 * and com.google.i18n.phonenumbers.Phonenumber.PhoneNumber;
	 *  
	 * @param inPhone - The phone to normalize as a String
	 * @return - The same phone number, but in ########## format 
	 */
	public static String parsePhone(String inPhone){
		PhoneNumber ph = null;
		try {
			ph = new PhoneNumber();
			PhoneNumberUtil phoneUtil = PhoneNumberUtil.getInstance();
			ph = phoneUtil.parse(inPhone, "US");
		} catch (NumberParseException e) {
			errLog.append("NumberParseException was thrown: " + e.toString() + "\n");
		}
		return ph.getNationalNumber() + "";
	}


	/**
	 * Normalize a date in the form of YYYY-MM-DD to MMDDYYYY
	 * @param inDate - a string in the form of YYYY-MM-DD
	 * @return - The same date but in MMDDYYYY form
	 */
	private static String parseMySQLDate(String inDate)
	{

		StringBuilder s = new StringBuilder();
		// Return strings not in YYYY-MM-DD format
		if (inDate.length()!= 10)
			return s.toString();

		// Return empty dates
		if (inDate.charAt(0) == '0')
			return s.toString();

		// Get all the characters except the 4th and 7th
		for (int i = 0 ; i < 10; i++)
			if (i != 4 && i != 7)
				s.append(inDate.charAt(i));

		return s.toString();
	}

	public static String normalizeDate(String inDate)
	{
//		String inPattern = "yyyy/MM/dd"; 
//		SimpleDateFormat format = new SimpleDateFormat(inPattern); 
//		Date date = null;
//		try { 
//			date = format.parse(inDate); 
//		//	System.out.println(format.format(date)); 
//		} catch (ParseException e) { 
//			e.printStackTrace(); 
//		}
//		format = new SimpleDateFormat("yyyy/MM/dd");
//		return parseMySQLDate(format.format(date));
		return inDate;
		//return parseMySQLDate(inDate);
	}

}